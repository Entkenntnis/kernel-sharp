using System;
using System.Text;
using System.IO;
using System.Text.RegularExpressions;
using System.Globalization;

namespace Kernel
{
    class MainClass
    {
        /* 
         * This is a rough implementation of the Kernel language described by John Shutt.
         * http://web.cs.wpi.edu/~jshutt/kernel.html
         * 
         * The major "improvement" to Scheme is the raising of special forms to first-class,
         * generated by $vau and then able to compose most of other language elements.
         * 
         * The evaluation model is quite straightforward and therefore easy to implement.
         * Not so continuations. The biggest deviation may be the ommision of call/cc and Co.
         * They may be tackled in another project. Tail recursion is available, though.
         * 
         * Regarding the R-1RK draft, Chapter 0 to Chapter 6 has been completely implemented,
         * also Chapter 8 & 9. Against the definition this implementation is case-sensitive.
         * 
         * Only double (inexact) and long (exact) numbers are implemented and binary operations
         * on them - sufficient for most non-mathematical applications.
         * 
         * This is the proof of concept that a expressive and powerful language can be defined
         * in a simple and clear approach.
         * 
         */
        public static void Main(string[] args)
        {
            Console.WriteLine("Welcome to Kernel#harp! Call (exit) to quit.\n");


            // user added functionality to the parser
            Parser.ExtendDefinition(new TokenDefinition(new Regex(@"""[^""\\]*(?:\\.[^""\\]*)*"""), "string", 80)); // user

            Parser.ExtendTextHandler(new TextHandler(75, (Token x) => { // user
                return x.Value == "#e-infinity"?new KDouble(Double.NegativeInfinity):null;
            }));
            Parser.ExtendTextHandler(new TextHandler(70, (Token x) => { // user
                return x.Value == "#e+infinity"?new KDouble(Double.PositiveInfinity):null;
            }));
            Parser.ExtendTextHandler(new TextHandler(65, (Token x) => { // user
                long l;
                if (long.TryParse(x.Value, out l))
                        return new KInteger(l);
                else
                    return null;
            }));
            Parser.ExtendTextHandler(new TextHandler(60, (Token x) => { // user
                double d;
                if (!x.Value.Contains("Infinity") &&  double.TryParse(x.Value,NumberStyles.Float, CultureInfo.InvariantCulture, out d))
                    return new KDouble(d);
                return false;
            }));
            Parser.ExtendHandler("string", (Token x) => { // user
                string sub = x.Value.Substring(1, x.Value.Length - 2);
                sub = sub.Replace("\\n", "\n").Replace("\\t", "\t").Replace("\\\"", "\"").Replace("\\r", "\r");
                return new KString(sub);
            });






            Interpreter p = new Interpreter();

            args = new string[]{ "(load \"/home/dal/Schreibtisch/kernel\")" };

            if (args.Length > 0)
            {
                foreach (string datum in args)
                {
                    p.RunCode(datum);
                }
            }
                
            p.REPL();
        }
    }
}
